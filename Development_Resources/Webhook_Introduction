---
title: Introduction
description: Receive real-time event notifications when flows execute.
---

## What Are Webhooks?

Webhooks deliver **real-time notifications** to your application when events occur during a user's flow execution. Instead of polling the API, your server automatically receives an HTTP POST request the moment something changes.

In the TrustPlatform, every verification runs as a **flow** — a series of **nodes** like identity checks, document verification, or digital signatures. Because nodes execute **asynchronously** (based on user behavior, device performance, and third-party services), webhooks keep your system synchronized with the flow's current state.

<Info>
**Key characteristics:**
- Thin payloads only (never contains PII)
- All events sent by default
- Asynchronous delivery (order not guaranteed)
- Automatic retries for transient failures
</Info>

---

## Webhook Lifecycle

The webhook system operates in four phases:

<Steps>
  <Step title="Setup Phase">
    Configure your webhook endpoint in Studio
  </Step>
  <Step title="Runtime Phase">
    Events are generated and delivered as flows execute
  </Step>
  <Step title="Customer Handling">
    Your endpoint validates, processes, and acknowledges events
  </Step>
  <Step title="Retry & Monitoring">
    Failed deliveries are retried; all attempts are logged
  </Step>
</Steps>

---

## Quick Start Checklist

Before receiving webhooks, complete these steps:

<Check>**Expose a secure HTTPS endpoint** supporting TLS 1.2+ for receiving POST requests</Check>

<Check>**Allowlist official IDnow IP ranges** to block unauthorized sources</Check>

<Check>**Enable JWT signature verification** using your configured secret (recommended)</Check>

<Check>**Respond with HTTP 2xx within 10 seconds** and process events asynchronously</Check>

<Check>**Use `event_id` for idempotency** to avoid duplicate event handling</Check>

<Note>
These steps ensure reliable delivery, secure processing, and smooth integration.
</Note>

---

## Common Use Cases

Webhooks fire whenever a flow transitions to a new state, allowing your backend to react instantly:

<CardGroup cols={2}>
  <Card title="Flow Created" icon="plus">
    A new flow execution record is initialized
    
    `flow_execution.created`
  </Card>
  
  <Card title="Flow Started" icon="play">
    The user has entered and begun the flow
    
    `flow_execution.started`
  </Card>
  
  <Card title="Flow Completed" icon="circle-check">
    All required nodes have successfully finished
    
    `flow_execution.completed`
  </Card>
  
  <Card title="Flow Expired" icon="clock">
    The flow reached its TTL without completion
    
    `flow_execution.expired`
  </Card>
  
  <Card title="Flow Error" icon="triangle-exclamation">
    A node failure halted the flow
    
    `flow_execution.error`
  </Card>
  
  <Card title="Flow Aborted" icon="circle-xmark">
    The flow was terminated before completion
    
    `flow_execution.aborted`
  </Card>
</CardGroup>

<Tip>
These events keep your system **synchronized, predictable, and responsive** — enabling you to automate reactions, trigger internal workflows, or update UI states without ever polling again.
</Tip>

---

## What's Next?

<CardGroup cols={2}>
  <Card title="Setup Guide" icon="gear" href="/webhooks/setup">
    Configure your webhook endpoint step-by-step
  </Card>
  <Card title="Event Reference" icon="bolt" href="/webhooks/events">
    View all available events and payload examples
  </Card>
  <Card title="Security" icon="shield" href="/webhooks/security">
    Implement signature verification and best practices
  </Card>
  <Card title="Full Overview" icon="book" href="/webhooks/overview">
    Deep dive into the complete webhook system
  </Card>
</CardGroup>
